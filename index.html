<!DOCTYPE html>
<html lang="id" class="dark">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Fast Face Blur UPSKK</title>
  
  <script src="https://cdn.tailwindcss.com"></script>

  <link href="https://fonts.googleapis.com" rel="preconnect">
  <link crossorigin="" href="https://fonts.gstatic.com" rel="preconnect">
  <link href="https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@400;500;700&display=swap" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined" rel="stylesheet"/>

  <script src="https://cdn.jsdelivr.net/npm/face-api.js@0.22.2/dist/face-api.min.js"></script>
  
  <style>
    body {
      font-family: 'Space Grotesk', sans-serif;
    }
    .range-slider {
      -webkit-appearance: none;
      width: 100%;
      height: 8px;
      border-radius: 5px;
      background: #d3d3d3;
      outline: none;
    }
    .range-slider::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 20px;
      height: 20px;
      border-radius: 50%;
      background: #3b82f6;
      cursor: pointer;
    }
    .range-slider::-moz-range-thumb {
      width: 20px;
      height: 20px;
      border-radius: 50%;
      background: #3b82f6;
      cursor: pointer;
    }
    .loading-overlay {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.7);
      z-index: 100;
      justify-content: center;
      align-items: center;
      flex-direction: column;
      color: white;
    }
    .spinner {
      border: 4px solid rgba(255, 255, 255, 0.3);
      border-radius: 50%;
      border-top: 4px solid white;
      width: 40px;
      height: 40px;
      animation: spin 1s linear infinite;
      margin-bottom: 15px;
    }
    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }
    .control-panel {
      background: rgba(255, 255, 255, 0.9);
      border-radius: 10px;
      padding: 15px;
      margin-bottom: 20px;
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
    }
    .dark .control-panel {
      background: white;
    }
    .blur-option {
      transition: all 0.2s ease;
    }
    .blur-option.active {
      background-color: #3b82f6;
      color: white;
    }
  </style>
</head>
<body class="bg-gray-50 text-slate-900 dark:bg-gray-900 dark:text-gray-100 min-h-screen flex flex-col">

  <!-- Loading Overlay -->
  <div id="loadingOverlay" class="loading-overlay">
    <div class="spinner"></div>
    <p id="loadingText">Memproses gambar...</p>
  </div>

  <header class="sticky top-0 z-50 w-full border-b border-slate-200/50 dark:border-slate-800/50 bg-white/80 dark:bg-gray-900/80 backdrop-blur-sm">
    <div class="container mx-auto flex items-center justify-between px-4 py-3">
      <div class="flex items-center gap-3">
        <svg class="h-8 w-8 text-blue-600 dark:text-blue-400" fill="currentColor" viewBox="0 0 24 24">
          <path d="M12 2C6.48 2 2 6.48 2 12s4.48 
          10 10 10 10-4.48 10-10S17.52 2 
          12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 
          8-8 8 3.59 8 8-3.59 8-8 
          8zM8 11h8v2H8v-2zm-3.5-3.5c-.83 
          0-1.5-.67-1.5-1.5S3.67 4.5 
          4.5 4.5s1.5.67 1.5 
          1.5S5.33 7.5 4.5 7.5zm15 
          0c-.83 0-1.5-.67-1.5-1.5s.67-1.5 
          1.5-1.5 1.5.67 1.5 
          1.5-.67 1.5-1.5 
          1.5zm-5.83 8.33c-1.39 1.39-3.59 
          1.39-4.98 0-.2-.2-.2-.51 
          0-.71s.51-.2.71 
          0c1.19 1.19 3.16 1.19 4.34 
          0 .2-.2.51-.2.71 0s.2.51 0 
          .71z"></path>
        </svg>
        <h2 class="text-xl font-bold text-slate-900 dark:text-white">BlurryFace by UPSKK</h2>
      </div>

      <div class="flex items-center gap-2">
        <button id="themeToggle" class="p-2 rounded-lg border border-slate-300 dark:border-slate-700 hover:bg-slate-200 dark:hover:bg-slate-800 transition">
          <span id="themeIcon" class="material-symbols-outlined text-slate-700 dark:text-slate-200">dark_mode</span>
        </button>
      </div>
    </div>
  </header>

  <main class="flex-grow container mx-auto px-4 py-8 sm:py-16">
    <div class="mx-auto max-w-3xl text-center">
      <h1 class="text-4xl sm:text-5xl font-bold tracking-tight text-slate-900 dark:text-white">
        Blur Faces in Your Images Instantly
      </h1>
      <p class="mt-4 text-lg text-slate-600 dark:text-slate-400">
        Protect privacy by automatically blurring faces in your photos. Upload an image and let our AI do the work, or take control with manual blurring tools.
      </p>
    </div>

    <div class="mt-10 flex flex-col items-center">
      <input type="file" id="imageUpload" accept="image/*"
        class="mb-6 block text-sm text-gray-700 dark:text-gray-300 
               file:mr-4 file:py-2 file:px-4 
               file:rounded-lg file:border-0 file:text-sm file:font-semibold
               file:bg-blue-600 file:text-white hover:file:bg-blue-500 cursor-pointer"/>

      <div class="control-panel w-full max-w-4xl">
        <div class="mb-4">
          <label for="blurType" class="block text-sm font-medium mb-2">Jenis Blur:</label>
          <div class="flex flex-wrap gap-2 mb-4">
            <button id="blurGaussian" class="blur-option active px-3 py-2 rounded-md bg-blue-100 dark:bg-blue-900 text-blue-800 dark:text-blue-200 font-medium">Gaussian Blur</button>
            <button id="blurPixelate" class="blur-option px-3 py-2 rounded-md bg-gray-200 dark:bg-gray-700 text-gray-800 dark:text-gray-200 font-medium">Pixelate</button>
            <button id="blurBlackBar" class="blur-option px-3 py-2 rounded-md bg-gray-200 dark:bg-gray-700 text-gray-800 dark:text-gray-200 font-medium">Black Bar</button>
          </div>
          
          <label for="blurIntensity" class="block text-sm font-medium mb-2">Intensiti Blur: <span id="blurValue">20</span>px</label>
          <input type="range" id="blurIntensity" min="5" max="50" value="20" class="range-slider">
        </div>
        
        <div class="flex flex-wrap justify-center gap-3">
          <button onclick="autoBlur()" class="px-4 py-2 rounded-lg bg-blue-600 hover:bg-blue-500 text-white font-medium shadow">Blur Automatik</button>
          <button onclick="resetImage()" class="px-4 py-2 rounded-lg bg-gray-700 hover:bg-gray-600 text-white font-medium shadow">Reset</button>
          <button onclick="undo()" class="px-4 py-2 rounded-lg bg-yellow-600 hover:bg-yellow-500 text-white font-medium shadow">Undo</button>
          <button onclick="redo()" class="px-4 py-2 rounded-lg bg-purple-600 hover:bg-purple-500 text-white font-medium shadow">Redo</button>
          <button onclick="downloadImage()" class="px-4 py-2 rounded-lg bg-green-600 hover:bg-green-500 text-white font-medium shadow">Download</button>
        </div>
      </div>

      <div class="w-full max-w-4xl">
        <canvas id="canvas" class="border border-gray-600 rounded-xl shadow-lg w-full cursor-crosshair"></canvas>
      </div>
    </div>
  </main>

  <script>
    // === Dark/Light Toggle ===
    const html = document.documentElement;
    const themeToggle = document.getElementById("themeToggle");
    const themeIcon = document.getElementById("themeIcon");

    function updateThemeIcon() {
      if (html.classList.contains("dark")) {
        themeIcon.textContent = "light_mode";
      } else {
        themeIcon.textContent = "dark_mode";
      }
    }

    themeToggle.addEventListener("click", () => {
      html.classList.toggle("dark");
      updateThemeIcon();
    });

    updateThemeIcon();

    // === Global Variables ===
    let currentImage;
    let history = [];
    let historyIndex = -1;
    let blurIntensity = 20;
    let blurType = 'gaussian'; // Default blur type

    // === Blur Type Selection ===
    function initializeBlurTypeSelection() {
      const blurGaussian = document.getElementById('blurGaussian');
      const blurPixelate = document.getElementById('blurPixelate');
      const blurBlackBar = document.getElementById('blurBlackBar');
      
      // Pastikan elemen ada sebelum menambahkan event listener
      if (blurGaussian && blurPixelate && blurBlackBar) {
        blurGaussian.addEventListener('click', () => setBlurType('gaussian'));
        blurPixelate.addEventListener('click', () => setBlurType('pixelate'));
        blurBlackBar.addEventListener('click', () => setBlurType('blackBar'));
        
        // Set default active state
        setBlurType('gaussian');
      } else {
        console.error('Salah satu tombol blur tidak ditemukan');
      }
    }

    function setBlurType(type) {
      blurType = type;
      
      // Dapatkan semua tombol blur
      const blurGaussian = document.getElementById('blurGaussian');
      const blurPixelate = document.getElementById('blurPixelate');
      const blurBlackBar = document.getElementById('blurBlackBar');
      
      // Reset semua tombol ke state tidak aktif
      [blurGaussian, blurPixelate, blurBlackBar].forEach(button => {
        if (button) {
          button.classList.remove('active', 'bg-blue-100', 'dark:bg-blue-900', 'text-blue-800', 'dark:text-blue-200');
          button.classList.add('bg-gray-200', 'dark:bg-gray-700', 'text-gray-800', 'dark:text-gray-200');
        }
      });
      
      // Set tombol aktif berdasarkan jenis blur
      let activeButton;
      switch(type) {
        case 'gaussian':
          activeButton = blurGaussian;
          break;
        case 'pixelate':
          activeButton = blurPixelate;
          break;
        case 'blackBar':
          activeButton = blurBlackBar;
          break;
      }
      
      if (activeButton) {
        activeButton.classList.remove('bg-gray-200', 'dark:bg-gray-700', 'text-gray-800', 'dark:text-gray-200');
        activeButton.classList.add('active', 'bg-blue-100', 'dark:bg-blue-900', 'text-blue-800', 'dark:text-blue-200');
      }
    }

    // === Loading Indicator Functions ===
    function showLoading(text = "Memproses gambar...") {
      const overlay = document.getElementById("loadingOverlay");
      const loadingText = document.getElementById("loadingText");
      loadingText.textContent = text;
      overlay.style.display = "flex";
    }

    function hideLoading() {
      const overlay = document.getElementById("loadingOverlay");
      overlay.style.display = "none";
    }

    // === Blur Intensity Control ===
    const blurSlider = document.getElementById("blurIntensity");
    const blurValue = document.getElementById("blurValue");

    if (blurSlider && blurValue) {
      blurSlider.addEventListener("input", function() {
        blurIntensity = parseInt(this.value);
        blurValue.textContent = blurIntensity;
      });
    }

    // === Model Loading ===
    async function loadFaceModels() {
      try {
        showLoading("Memuat model AI...");
        
        // Menggunakan model dari CDN yang tersedia
        await faceapi.nets.ssdMobilenetv1.loadFromUri('https://justadudewhohacks.github.io/face-api.js/models');
        await faceapi.nets.faceLandmark68Net.loadFromUri('https://justadudewhohacks.github.io/face-api.js/models');
        
        hideLoading();
        console.log('✅ Model wajah berhasil dimuat');
      } catch (error) {
        hideLoading();
        console.error('❌ Gagal memuat model wajah:', error);
        alert('Gagal memuat model wajah. Periksa konsol untuk detail.');
      }
    }

    // Initialize models when page loads
    document.addEventListener('DOMContentLoaded', async () => {
      // Inisialisasi pemilihan jenis blur
      initializeBlurTypeSelection();
      
      if (typeof faceapi === 'undefined') {
        console.error('faceapi tidak didefinisikan.');
        alert('Pustaka face-api.js gagal dimuat.');
        return;
      }
      
      await loadFaceModels();
      
      const imageUpload = document.getElementById('imageUpload');
      if (imageUpload) {
        imageUpload.addEventListener('change', handleImageUpload);
      }
    });

    // === BLUR FACE FUNCTIONS ===
    async function handleImageUpload(event) {
      const input = event.target.files[0];
      if (!input) return;
      
      showLoading("Memuat gambar...");
      
      try {
        currentImage = await faceapi.bufferToImage(input);
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d', { willReadFrequently: true });
        canvas.width = currentImage.width;
        canvas.height = currentImage.height;
        ctx.drawImage(currentImage, 0, 0);
        saveState();
        hideLoading();
      } catch (error) {
        hideLoading();
        console.error('❌ Gagal memuat gambar:', error);
        alert('Gagal memuat gambar. Pastikan file adalah gambar yang valid.');
      }
    }

    // Function to apply different blur types
    function applyBlurEffect(ctx, x, y, width, height) {
      switch(blurType) {
        case 'gaussian':
          // Gaussian blur using CSS filter
          ctx.save();
          ctx.beginPath();
          ctx.ellipse(x + width/2, y + height/2, width/2 * 1.1, height/2 * 1.3, 0, 0, 2 * Math.PI);
          ctx.clip();
          ctx.filter = `blur(${blurIntensity}px)`;
          ctx.drawImage(currentImage, 0, 0, currentImage.width, currentImage.height);
          ctx.restore();
          break;
          
        case 'pixelate':
          // Pixelation effect
          const pixelSize = Math.max(1, Math.floor(blurIntensity / 2));
          const smallCanvas = document.createElement('canvas');
          const smallCtx = smallCanvas.getContext('2d');
          
          // Create a small version of the area
          smallCanvas.width = Math.ceil(width / pixelSize);
          smallCanvas.height = Math.ceil(height / pixelSize);
          smallCtx.drawImage(currentImage, x, y, width, height, 0, 0, smallCanvas.width, smallCanvas.height);
          
          // Draw the pixelated version back
          ctx.save();
          ctx.beginPath();
          ctx.ellipse(x + width/2, y + height/2, width/2 * 1.1, height/2 * 1.3, 0, 0, 2 * Math.PI);
          ctx.clip();
          ctx.imageSmoothingEnabled = false;
          ctx.drawImage(smallCanvas, 0, 0, smallCanvas.width, smallCanvas.height, x, y, width, height);
          ctx.restore();
          break;
          
        case 'blackBar':
          // Black bar effect
          ctx.save();
          ctx.beginPath();
          ctx.ellipse(x + width/2, y + height/2, width/2 * 1.1, height/2 * 1.3, 0, 0, 2 * Math.PI);
          ctx.clip();
          ctx.fillStyle = 'black';
          ctx.fillRect(x, y, width, height);
          ctx.restore();
          break;
      }
    }

    async function autoBlur() {
      if (!currentImage) return alert('Muat naik gambar dulu.');
      
      showLoading("Mendeteksi dan mengaburkan wajah...");
      
      const canvas = document.getElementById('canvas');
      const ctx = canvas.getContext('2d', { willReadFrequently: true });
      ctx.drawImage(currentImage, 0, 0);
      
      try {
        const detections = await faceapi.detectAllFaces(currentImage).withFaceLandmarks();
        
        if (detections.length === 0) {
          hideLoading();
          alert('Tidak ada wajah yang terdeteksi dalam gambar.');
          return;
        }
        
        detections.forEach(detection => {
          const box = detection.detection.box;
          applyBlurEffect(ctx, box.x, box.y, box.width, box.height);
        });
        
        saveState();
        hideLoading();
      } catch (error) {
        hideLoading();
        console.error('❌ Gagal kesan wajah:', error);
        alert('Gagal memproses gambar. Pastikan model AI telah dimuat dengan benar.');
      }
    }

    // Manual blur with click
    const canvas = document.getElementById('canvas');
    if (canvas) {
      canvas.addEventListener('click', (event) => {
        if (!currentImage) return alert('Muat naik gambar dahulu.');
        
        const rect = canvas.getBoundingClientRect();
        const scaleX = canvas.width / rect.width;
        const scaleY = canvas.height / rect.height;
        const clickX = (event.clientX - rect.left) * scaleX;
        const clickY = (event.clientY - rect.top) * scaleY;
        
        const ctx = canvas.getContext('2d', { willReadFrequently: true });
        
        // Apply blur effect at click position with default size
        const blurWidth = 80;
        const blurHeight = 110;
        applyBlurEffect(ctx, clickX - blurWidth/2, clickY - blurHeight/2, blurWidth, blurHeight);
        
        saveState();
      });
    }

    function saveState() {
      const canvas = document.getElementById('canvas');
      if (historyIndex < history.length - 1) {
        history = history.slice(0, historyIndex + 1);
      }
      history.push(canvas.toDataURL());
      historyIndex++;
    }

    function resetImage() {
      if (!currentImage) return alert('Tidak ada gambar.');
      const canvas = document.getElementById('canvas');
      const ctx = canvas.getContext('2d');
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.drawImage(currentImage, 0, 0);
      history = [];
      historyIndex = -1;
      saveState();
    }

    function undo() {
      if (historyIndex > 0) {
        historyIndex--;
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const image = new Image();
        image.onload = () => {
          ctx.clearRect(0, 0, canvas.width, canvas.height);
          ctx.drawImage(image, 0, 0);
        };
        image.src = history[historyIndex];
      } else alert('Tidak ada undo.');
    }

    function redo() {
      if (historyIndex < history.length - 1) {
        historyIndex++;
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const image = new Image();
        image.onload = () => {
          ctx.clearRect(0, 0, canvas.width, canvas.height);
          ctx.drawImage(image, 0, 0);
        };
        image.src = history[historyIndex];
      } else alert('Tidak ada redo.');
    }

    function downloadImage() {
      const canvas = document.getElementById('canvas');
      if (!canvas.width || !canvas.height) return alert('Tidak ada gambar.');
      const link = document.createElement('a');
      link.download = 'blurred_image.png';
      link.href = canvas.toDataURL('image/png');
      link.click();
    }
  </script>
</body>
</html>


